/**
 * @file FaultSimulator.cpp
 * @author Spencer Millican (millican@auburn.edu)
 * @version 0.1
 * @date 2019-01-21
 *
 * @copyright Copyright (c) 2019
 *
 */

#include "FaultSimulator.h"
#include "ValueVectorFunctions.hpp"

template<class _primitive>
FaultSimulator<_primitive>::FaultSimulator(bool _tdfEnable) {
	this->tdfEnable_ = _tdfEnable;
}

template<class _primitive>
FaultSimulator<_primitive>::~FaultSimulator() {
	this->clearFaults();
}

template<class _primitive>
std::vector<Value<_primitive>> FaultSimulator<_primitive>::applyStimulus(
	Circuit * _circuit, 
	std::vector<Value<_primitive>> _stimulus,
	EventQueue<_primitive> _simulationQueue,
	std::vector<SimulationNode<_primitive>*> _inputs,
	std::vector<SimulationNode<_primitive>*> _outputs,
	std::vector<bool> _observe
)
{

	std::unordered_set<Fault<_primitive>*> preProcessFaults;

	//If TDF mode is enabled, do the preliminary fault elimination based on the
	//current circuit state.
	if (this->tdfEnable_ == true) {
		for (Fault<_primitive>* fault : this->undetectedFaults_) {
			if (this->notExcited(fault) == true) {
				preProcessFaults.emplace(fault);
			}
		}
	}
	else {
		preProcessFaults = this->undetectedFaults_;
	}

	if (_outputs.empty() == true) {
		for (Levelized* output : _circuit->pos()) {
			_outputs.push_back(dynamic_cast<SimulationNode<_primitive>*>(output));
		}
		//DELETE: doesn't work, won't compile. _outputs = std::vector<SimulationNode<T>*>(_circuit->pos().begin(), _circuit->pos().end());
	}
	if (_observe.empty() == true) {
		_observe = std::vector<bool>(_outputs.size(), true);
	} else if (_observe.size() != _outputs.size()) {
		throw "_outputs/_observe size mismach during fault simulation.";
	}

	//Obatin the "non-faulty" state.
	std::vector<Value<_primitive>> goodOutputs  = this->Simulator<_primitive>::applyStimulus(_circuit, _stimulus, _simulationQueue, _inputs, _outputs, _observe);
	//DELETE: not needed. this->Simulator<_primitive>::applyStimulus(_circuit,  _stimulus,  _simulationQueue, _inputs);
	//DELETE: not needed. std::vector<Value<_primitive>> goodOutputs = this->outputs(_circuit);

	//Obtain all faults which are "worth simulating".
	std::unordered_set<Fault<_primitive>*> faults;
	for (Fault<_primitive>* fault : preProcessFaults) {
		if (this->hasImpact(fault) == true) {
			faults.emplace(fault);
		}
	}

	//Simulate every fault.
	for (Fault<_primitive>* fault : faults) {
		
		_simulationQueue.add(fault->go()); //NOTE: "Go" will toggle the activation of the fault and return all new events from this (de)activation.
		//DELETE do we need this? this->Simulator<_primitive>::applyStimulus(_circuit, _stimulus, _simulationQueue, _inputs);
		_simulationQueue.process();
		std::vector<Value<_primitive>> faultyOutputs = this->outputs(_circuit, _outputs, _observe);
		if (ValueVectorFunction<_primitive>::mismatch(goodOutputs, faultyOutputs, _observe) == true) {
			this->undetectedFaults_.erase(fault);
			this->detectedFaults_.emplace(fault);
		}

		_simulationQueue.add(fault->go()); //NOTE: "Go" will toggle the activation of the fault and return all new events from this (de)activation.
		//DEBUG: I want to know ALL stimulus generated by a fault alone.
		_simulationQueue.process();
		
	}

	//Reset the state of the circuit. //NOTE: is this step needed?
	this->Simulator<_primitive>::applyStimulus(_circuit, _stimulus, _simulationQueue, _inputs, _outputs, _observe);
	return goodOutputs;
}

template<class _primitive>
void FaultSimulator<_primitive>::setFaults(std::unordered_set<Fault<_primitive>*> _faults) {
	this->clearFaults();
	this->undetectedFaults_ = _faults;
}

template<class _primitive>
void FaultSimulator<_primitive>::resetFaults() {
	this->undetectedFaults_.insert(this->detectedFaults_.begin(), this->detectedFaults_.end());
	this->detectedFaults_.clear();
}



template<class _primitive>
std::unordered_set<Fault<_primitive>*> FaultSimulator<_primitive>::detectedFaults() {
	return this->detectedFaults_;
}

template<class _primitive>
float FaultSimulator<_primitive>::faultcoverage() {
	
	float fc = (float) detectedFaults_.size() /((float) detectedFaults_.size() + (float) undetectedFaults_.size());
	return fc*100;
}




template<class _primitive>
bool FaultSimulator<_primitive>::hasImpact(Fault<_primitive>* _fault) {
	Value<_primitive> curLineValue = _fault->location()->value();
	Value<_primitive> faultValue = _fault->value();
	return curLineValue != faultValue;
}

template<class _primitive>
bool FaultSimulator<_primitive>::notExcited(Fault<_primitive>* _fault) {
	Value<_primitive> curLineValue = _fault->location()->value();
	Value<_primitive> faultValue = _fault->value();
	if (curLineValue.valid() == false || faultValue.valid() == false) {
		return false;
	}
	return curLineValue.magnitude() == faultValue.magnitude();
}

template<class _primitive>
void FaultSimulator<_primitive>::clearFaults() {
	for (Fault<_primitive>* fault : this->detectedFaults_) {
		delete fault;
	}
	this->detectedFaults_.clear();
	for (Fault<_primitive>* fault : this->undetectedFaults_) {
		delete fault;
	}
	this->undetectedFaults_.clear();
}

template class FaultSimulator<bool>;
template class FaultSimulator<unsigned long long int>;