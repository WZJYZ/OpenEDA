/**
 * @file FaultSimulator.cpp
 * @author Spencer Millican (millican@auburn.edu)
 * @version 0.1
 * @date 2019-01-21
 *
 * @copyright Copyright (c) 2019
 *
 */

#include "FaultSimulator.h"
#include "ValueVectorFunctions.hpp"

template<class _primitive>
FaultSimulator<_primitive>::FaultSimulator(bool _tdfEnable) {
	this->tdfEnable_ = _tdfEnable;
}

template<class _primitive>
FaultSimulator<_primitive>::~FaultSimulator() {
	this->clearFaults();
}

template<class _primitive>
std::vector<Value<_primitive>> FaultSimulator<_primitive>::applyStimulus(Circuit * _circuit, 
	std::vector<Value<_primitive>> _stimulus,
	std::vector<float> _observe,
	EventQueue<_primitive> _simulationQueue,
	std::vector<SimulationNode<_primitive>*> _inputs)
{

	std::unordered_set<Fault<_primitive>*> preProcessFaults;

	//If TDF mode is enabled, do the preliminary fault elimination based on the
	//current circuit state.
	if (this->tdfEnable_ == true) {
		for (Fault<_primitive>* fault : this->undetectedFaults_) {
			if (this->notExcited(fault) == true) {
				preProcessFaults.emplace(fault);
			}
		}
	}
	else {
		preProcessFaults = this->undetectedFaults_;
	}

	//Obatin the "non-faulty" state.
	this->Simulator<_primitive>::applyStimulus(_circuit,  _stimulus,  _simulationQueue, _inputs);
	std::vector<Value<_primitive>> goodOutputs = this->outputs(_circuit);

	//Obtain all faults which are "worth simulating".
	std::unordered_set<Fault<_primitive>*> faults;
	for (Fault<_primitive>* fault : preProcessFaults) {
		if (this->hasImpact(fault) == true) {
			faults.emplace(fault);
		}
	}

	//Simulate every fault.
	for (Fault<_primitive>* fault : faults) {
		
		_simulationQueue.add(fault->go()); //NOTE: "Go" will toggle the activation of the fault and return all new events from this (de)activation.
		//DELETE do we need this? this->Simulator<_primitive>::applyStimulus(_circuit, _stimulus, _simulationQueue, _inputs);
		_simulationQueue.process();
		std::vector<Value<_primitive>> faultyOutputs = this->outputs(_circuit);
		bool flag = true;
		if (ValueVectorFunction<_primitive>::mismatch(goodOutputs, faultyOutputs)) {

			for (int i = 0; i < _observe.size(); i++) //The fault is detected.
			{
				if (_observe.at(i) < (rand() / (float)RAND_MAX))
				{
					flag = false;
					break;
				}


			}
		}
		if (flag == true)
		{
			this->undetectedFaults_.erase(fault);
			this->detectedFaults_.emplace(fault);
		}
			_simulationQueue.add(fault->go()); //NOTE: "Go" will toggle the activation of the fault and return all new events from this (de)activation.
			//DEBUG: I want to know ALL stimulus generated by a fault alone.
			_simulationQueue.process();
		
	}

	//Reset the state of the circuit. //NOTE: is this step needed?
	this->Simulator<_primitive>::applyStimulus(_circuit, _stimulus, _simulationQueue, _inputs);
	return goodOutputs;
}

template<class _primitive>
void FaultSimulator<_primitive>::setFaults(std::unordered_set<Fault<_primitive>*> _faults) {
	this->clearFaults();
	this->undetectedFaults_ = _faults;
}

template<class _primitive>
void FaultSimulator<_primitive>::resetFaults() {
	this->undetectedFaults_.insert(this->detectedFaults_.begin(), this->detectedFaults_.end());
	this->detectedFaults_.clear();
}



template<class _primitive>
std::unordered_set<Fault<_primitive>*> FaultSimulator<_primitive>::detectedFaults() {
	return this->detectedFaults_;
}

template<class _primitive>
float FaultSimulator<_primitive>::faultcoverage() {
	
	float fc = (float) detectedFaults_.size() /((float) detectedFaults_.size() + (float) undetectedFaults_.size());
	return fc*100;
}




template<class _primitive>
bool FaultSimulator<_primitive>::hasImpact(Fault<_primitive>* _fault) {
	Value<_primitive> curLineValue = _fault->location()->value();
	Value<_primitive> faultValue = _fault->value();
	return curLineValue != faultValue;
}

template<class _primitive>
bool FaultSimulator<_primitive>::notExcited(Fault<_primitive>* _fault) {
	Value<_primitive> curLineValue = _fault->location()->value();
	Value<_primitive> faultValue = _fault->value();
	if (curLineValue.valid() == false || faultValue.valid() == false) {
		return false;
	}
	return curLineValue.magnitude() == faultValue.magnitude();
}

template<class _primitive>
void FaultSimulator<_primitive>::clearFaults() {
	for (Fault<_primitive>* fault : this->detectedFaults_) {
		delete fault;
	}
	this->detectedFaults_.clear();
	for (Fault<_primitive>* fault : this->undetectedFaults_) {
		delete fault;
	}
	this->undetectedFaults_.clear();
}

template class FaultSimulator<bool>;