/**
 * @file SAT.h
 * @author Spencer Millican (millican@auburn.edu)
 * @version 0.1
 * @date 2019-01-14
 *
 * @copyright Copyright (c) 2019
 *
 */

#ifndef SAT_h
#define SAT_h

#include <ctime>

#include "Simulator.h"
#include "Combination.hpp"
#include "SATStructures.hpp"
#include "Tracer.hpp"


/*
 * A Simulator restricted to flagged Nodes.
 *
 * Unlike a regular simulator, a RestrictedSimulator will not update Nodes
 * (and their outputs) unless the Node is flagged. Therefore, Nodes in this
 * Simulator must be Tracable.
 *
 * @param _primitive The underlying data primitive to simulate.
 * @param _lineType Tye type of lines used in the circuit.
 * @param _nodeType The type of node which combinations will be implemented as
 *                  and the type of nodes to simulate. This must inherit
 *                  from "TraceNode".
 */
template <class _primitive, class _lineType, class _nodeType>
class RestrictedSimulator : public Simulator<_primitive> {
public:
	/*
	 * Set restrictions to a given set of Nodes.
	 *
	 * @param _nodes Nodes to active simulation to (i.e., to flag).
	 */
	void setActiveSimulationNodes(std::unordered_set < Tracable* > _nodes) {
		for (Tracable* node : _nodes) {
			node->flag(true);
		}
	};

	/*
	 * Unrestrict a given set of Nodes. Simultaneously, set all Node output values to "undefined".
	 *
	 * @param _nodes Nodes to unrestrict and to reset (i.e., to unflag).
	 */
	void unssetActiveSimulationNodes(std::unordered_set < Tracable* > _nodes) {
		for (Tracable* node : _nodes) {
			node->flag(false);
			if (node->inputs().size() == 0) { //SKIP nodes which do not have any inputs: PIs and combinations.
				continue;
			}
			Valued<_primitive>* cast = dynamic_cast<Valued<_primitive>*>(node);
			cast->value(std::vector<Value<_primitive>>(node->inputs().size(), Value<_primitive>()));
		}
		//DELETE: flawed
		/*for (Tracable* node : _nodes) {
			Connecting* output = *(node->outputs().begin());
			Valued<_primitive>* outputCast = dynamic_cast<Valued<_primitive>*>(output);
			outputCast->value(std::vector<Value<_primitive>>(output->inputs().size(), Value<_primitive>()));
			node->flag(false);
		}*/
	};

};

/*
 * Performs satisfiability (SAT) on Circuit Line-Value combinations.
 *
 * @param _primitive The underlying data primitive to simulate.
 * @param _lineType Tye type of lines used in the circuit.
 * @param _nodeType The type of nodes in the Circuit. This type must inherit
 *        from SATNode.
 */
template <class _primitive, class _lineType, class _nodeType>
class SAT {
public:
	/*
	 * Create and set a per-combination time limit (in seconds).
	 *
	 * @param _limit Time limit (in seconds).
	 */
	SAT(int _limit) {
		this->limit_ = _limit * CLOCKS_PER_SEC;
	}

	/*
	 * Perform SAT for a given Combination.
	 *
	 * NOTE: This function does not perform the actual SAT, but instead calls the
	 * internal SAT implementation.
	 *
	 * @param _circuit The circuit to apply inputs to.
	 * @param _combination The Combination to satisfy.
	 * @return The combination of Circuit inputs which satisfy the given combinations.
	 *         If the number of inputs given is "zero", then it cannot be satisfied.
	 */
	//DELETE: obsolete and can create confusion.
	//Combination<_primitive, _lineType, _nodeType> satisfy(Circuit* _circuit, Combination<_primitive, _lineType, _nodeType>* _combination) {
	//	this->prepare(_circuit);
	//	std::vector<_nodeType> pis;
	//	std::unordered_set<_nodeType> coi;
	//	Combination<_primitive, _lineType, _nodeType> toReturn = this->satisfy(_circuit, _combination, pis, coi);
	//	this->release(_circuit);
	//	return toReturn;
	//}

	/*
	 * Perform SAT for a given set of Combinations with a set of influencing PIs and COI.
	 * All Combinations given must be on the same Lines (and in the same order).
	 *
	 * NOTE: This function does not perform the actual SAT, but instead calls the
	 * internal SAT implementation.
	 *
	 * NOTE: "empty" PIs and COI can be given: it will then be generated by the function.
	 *
	 * @param _circuit The circuit to apply inputs to.
	 * @param _combination A set of Combinations to satisfy.
	 * @return The combinations which were satisfied, along with their satisfying input.
	 */
	std::vector<
		std::pair<
			Combination<_primitive, _lineType, _nodeType>*,
			Combination<_primitive, _lineType, _nodeType>
		>
	> satisfy(
		Circuit* _circuit,
		std::unordered_set<Combination<_primitive, _lineType, _nodeType>*> _combinations
	) {
		std::vector<
			std::pair<
			Combination<_primitive, _lineType, _nodeType>*,
			Combination<_primitive, _lineType, _nodeType>
			>
		> toReturn;
		if (_combinations.size() == 0) {
			return toReturn;
		}
		std::vector<_nodeType*> pis;
		std::unordered_set<Tracable*> coi;
		this->prepare(_circuit, _combinations, pis, coi);
		for (Combination<_primitive, _lineType, _nodeType>* combination : _combinations) {
			Combination<_primitive, _lineType, _nodeType> solution = this->satisfy(_circuit, combination, pis, coi);
			if (solution.lines().size() > 0) {
				toReturn.push_back(std::pair<
								 Combination<_primitive, _lineType, _nodeType>*,
								 Combination<_primitive, _lineType, _nodeType>
				>(combination, solution)
				);
			}
		}
		this->release(coi);
		return toReturn;
	}

protected:
	/*
	 * Perform sat for a given Combination.
	 *
	 * @param _circuit The circuit to apply inputs to.
	 * @param _combination The Combination to satisfy.
	 * @param _pis Primary inputs to apply stimulus to. If an empty list is given,
	 *        a trace will be performed (and can be re-used by calling functions).
	 * @param _coi The cone of influence. If an empty list is given, a trace will
	 *        be performed (and can be re-used by calling functions).
	 * @return The combination of Circuit inputs which satisfy the given combinations.
	 *         If the number of inputs given is "zero", then it cannot be satisfied.
	 */
	Combination<_primitive, _lineType, _nodeType> satisfy(Circuit* _circuit,
									Combination<_primitive, _lineType,  _nodeType>* _combination,
									std::vector<_nodeType*>& _pis,
									std::unordered_set<Tracable*>& _coi) {
		std::clock_t startTime = this->setup(_coi, _pis, _combination);
		std::vector<Value<_primitive>> currentPiValues = std::vector<Value<_primitive>>(_pis.size(), Value<_primitive>());
		//To be used in a simulator, the PIs need to be cast as a "SimulationNodes"
		std::vector<SimulationNode<_primitive>*> simulationPis = std::vector<SimulationNode<_primitive>*>(_pis.begin(), _pis.end());

		size_t stepNumber = 1;
		while (this->timeLeft(startTime) == true) {
			simulator_.applyStimulus(_circuit, currentPiValues, EventQueue<_primitive>(), simulationPis);
			if (_combination->seen() == true) {
				return this->success(_coi, _pis);
			}
			std::vector<Value<_primitive>> currentCombinationValues = _combination->currentValues();
			std::vector<Value<_primitive>> targetValues = _combination->targetValues();
			if (ValueVectorFunction<_primitive>::mismatch(currentCombinationValues, targetValues) == true) { //Mismatch: try backtracking
				if (ValueVectorFunction<_primitive>::backtrack(currentPiValues) == false) { //Backtracking failed: exaustive search completed.
					return this->fail(_coi);
				}
			} else {
				if (ValueVectorFunction<_primitive>::forwardtrack(currentPiValues) == false) {
					bool seen = _combination->seen();
					throw "Forward track error! This should never happen. Ever. Period. Something is seriously wrong with SAT.";
				}
			}
			stepNumber++;
		}
		return this->fail(_coi); //Out of time
	}

	/*
	 * Prepare a given Circuit for SAT (by disabling simulation on all Nodes).
	 *
	 * This function will set pis and cone-of-influence for the given combination.
	 *
	 * @param _circuit The Circuit to prepare.
	 * @param _combination The Combination to prepare for.
	 * @param _pis The pis of the Combination to prepare for. Returned by reference.
	 * @param _coi The coi of the Combination to prepare for. Returned by reference.
	 */
	void prepare(
		Circuit* _circuit,
		std::unordered_set<Combination<_primitive, _lineType, _nodeType>*> _combinations,
		std::vector<_nodeType*> & _pis,
		std::unordered_set<Tracable*> & _coi
	) {

		std::unordered_set<Tracable*> coi;
		std::unordered_set<_nodeType*> pis = Tracer<_lineType, _nodeType>::backwards(
			std::unordered_set<Tracable*>(_combinations.begin(), _combinations.end()),
			coi
		);
		_pis = std::vector<_nodeType*>(pis.begin(), pis.end());
		_coi = std::unordered_set<Tracable*>(coi.begin(), coi.end());

		simulator_.setActiveSimulationNodes(coi);
		//DELETE: flawed.
		/*for (Levelized* node : _circuit->nodes()) {
			_nodeType* cast = dynamic_cast<_nodeType*>(node);
			cast->flag(true);
		}*/
	}

	/*
	 * Release a given Circuit for SAT (by enabling simulation on all Nodes).
	 *
	 * @param _circuit The Circuit to release.
	 */
	void release(std::unordered_set<Tracable*> _coi) {
		simulator_.unssetActiveSimulationNodes(_coi);
		//DELETE: flawed.
		/*for (Levelized* node : _circuit->nodes()) {
			_nodeType* cast = dynamic_cast<_nodeType*>(node);
			cast->flag(false);
		}*/
	}

	/*
	 * With the current clock, is there time left?
	 *
	 * @param The start time of a given process.
	 * @return True if there is time left.
	 */
	bool timeLeft(clock_t _time) {
		if ((clock() - _time) < this->limit_) {
			return true;
		}
		return false;
	}

private:
	/*
	 * This function is called when a combination is failed to be found.
	 *
	 * @param _coi The cone-of-influence which needs to be reset.
	 * @return The "not found" combination (no inputs).
	 */
	Combination<_primitive, _lineType, _nodeType> fail(std::unordered_set<Tracable*>& _coi) {
		//DELETE: flawed. Shoould be called elsewhere. //simulator_.unssetActiveSimulationNodes(_coi);//for (SATNode<_primitive>* node : _coi) { node->flag(false); } 
		return Combination<_primitive, _lineType, _nodeType>();
	}

	/*
	 * This function is called when a combination is successfully found.
	 *
	 * @param _coi The cone-of-influence which needs to be reset.
	 * @param _pi The primary inputs which hold the successful values.
	 * @return The successful combination.
	 */
	Combination<_primitive, _lineType, _nodeType> success(std::unordered_set<Tracable*>& _coi, std::vector<_nodeType*>& _pis) {
		//DELETE: flawed. Shoould be called elsewhere.  // simulator_.unssetActiveSimulationNodes(_coi); //for (SATNode<_primitive>* node : _coi) {node->flag(false); } //
		Combination<_primitive, _lineType, _nodeType> toReturn = Combination<_primitive, _lineType, _nodeType>(_pis);
		return toReturn;
	}

	/*
	 * This function "sets up" a satisfiability instance.
	 *
	 * @param _coi The cone-of-influence which needs to be reset. May be empty.
	 * @param _pi The primary inputs which hold the successful values. May be empty.
	 * @param _combination The combination to set-up for.
	 * @return The time when setup is complete.
	 */
	std::clock_t setup(
		std::unordered_set<Tracable*>& _coi,
		std::vector<_nodeType*>& _pis, 
		Combination<_primitive, _lineType, _nodeType>* _combination 
	) {
		std::vector<_lineType*> combinationLines = _combination->lines();
		if (_pis.empty() || _coi.empty()) { //If pis & cone-of-influence not yet given, create it (and return it by reference).
			std::unordered_set<Tracable*> coi;
			std::unordered_set<_nodeType*> pis = Tracer<_lineType, _nodeType>::backwards(
				std::unordered_set<Tracable*>(combinationLines.begin(), combinationLines.end()),
				coi
			);
			_pis = std::vector<_nodeType*>(pis.begin(), pis.end());
			_coi = std::unordered_set<Tracable*>(coi.begin(), coi.end());
		}
		//Delete: flawed. Should be called elsewhere. //simulator_.setActiveSimulationNodes(_coi);
		std::clock_t startTime = std::clock();
		return startTime;
	}

	/*
	 * The Simulator which evalautes Circuit Values./
	 */
	RestrictedSimulator<_primitive, _lineType, _nodeType> simulator_;

	/*
	 * The per-combination time limit of this object (in clock ticks).
	 */
	clock_t limit_;

};

#endif